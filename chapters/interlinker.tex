\chapter{Velvet Fork Implementation}
We implement ... motivation TODO ...

\pdffigure{blocks-with-their-interlinks}{Example of blocks with their corresponding interlinks for $T = 100000$. Note that for the upcoming block marked with \textbf{?} we can produce its interlink without knowing its hash.}

Since Bitcoin Cash blocks don't contain the interlink we have to utilize a User-Activated Velvet Fork. To this end, we need to make sure that a transaction is included in every single block containing its implied interlink. We do this by implementing a service which for every new block, calculates the expected interlink of the upcoming block and sends a transaction including this interlink in hopes that it will be included in the upcoming block. If this is indeed achieved then that block will indeed contain its valid interlink. We henceforth call the service which does this an \emph{interlinker}. An example of blocks and their corresponding interlinks can be seen on Figure~\ref{fig:blocks-with-their-interlinks}.

\section{Picking a Velvet Genesis}
Naturally one would expect the interlink to start from the real blockchain genesis as it would enable proofs for any already existing block of that blockchain. However, for older blocks there can be no improvement. There is no other option than providing the full chain as a proof since no older blocks contain any interlinks. Thus in order to avoid accounting in our interlink for blocks in the past that can only be connected to the real genesis by supplying the full chain we choose a new genesis called the \emph{velvet genesis}. For our purposes in Bitcoin Cash testnet we chose the block with height 1257603 as our velvet genesis.

\section{Interlink encoding}
We now have to consider our options for representing the interlink. 
Bitcoin Cash uses SHA-256 for the block hashes, meaning that each block id consists of 32 bytes. 
A naive encoding would be one where each 32-byte block hash from level $0$ up to $\infty$ is concatenated, with the $\infty$ pointer always pointing to the genesis block..
For 35 levels, which according to Figure~\ref{fig:bitcoin-cash-testnet-levels-after-velvet-genesis} is a reasonable figure, this encoding would take approximately 1.12KB.
Considering that \code{OP\_RETURN} scripts are limited in size to 223 bytes, this would only allow us to include up to 6 pointers at best.

\begin{figure}
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{figures/bitcoin-cash-testnet-levels-after-velvet-genesis.pdf}
  \caption{Number of levels assuming our selected velvet genesis.}
  \label{fig:bitcoin-cash-testnet-levels-after-velvet-genesis}
\end{figure}

Putting this limitation aside, the fee of the transaction is proportional to the transaction size, and since we're going to be sending a transaction for every block (which is mined approximately every 10 minutes), it is important that the fee is minimized.

Thus in order to save space, we only include a commitment to the interlink in our transactions. Specifically, we take the Merkle Tree root of the Merkle Tree with leafs the block hashes starting from level $0$ up to $\infty$. This way, our interlink encoding is constant size and we can easily provide compact proofs for any of the levels.

\section{Discoverability}
We've talked about how just including the interlink somewhere on a block is what really matters but it is crucial that we make this information easy to discover. We achieve this in two ways. First, we include the interlink commitment inside a special \code{OP\_RETURN} output. Such outputs are already being used for storing arbitrary data in blocks~\cite{arbitrary-data} therefore we adopt this method for storing our interlinks. Second, we aim to make this interlink discoverable for lite nodes, so we don't require our users to download a whole block in order to look into it. We achieve this by utilizing a method called \emph{SPV tagged outputs}~\cite{spv-tagged}.

SPV tagged outputs are outputs that are tagged so that they can be discovered by SPV nodes who add the ``tag'' to the filter. Specifically, we form outputs of the form \code{OP\_RETURN baba deadbeef}, where \code{baba} is our tag and \code{deadbeef} is our payload (in our case, the interlink commitment). A bloom filter for \code{baba} will then match this output and subsequently the transaction that contains it and this is how our specialized SPV nodes can discover our outputs. The full nodes forwarding the velvet transactions to the SPV nodes don't have any knowledge of what a velvet fork even is, let alone that they are forwarding its transactions.

The tag we use for our transactions is \code{696e7465726c696e6b}, which is the ASCII encoding of \code{interlink}. An example of such a real-world velvet transaction created by our deployed interlinker on the Bitcoin Cash testnet can be seen on Figure~\ref{fig:actual-velvet-tx}.

\begin{figure}
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{figures/actual-velvet-tx.png}
  \caption{An actual velvet fork transaction.}
  \label{fig:actual-velvet-tx}
\end{figure}

\section{Fault Tolerance}
It is important to note that the interlinker works on a best-effort basis. Due to the nature of Velvet Forks though, no failure is fatal. The types of failures are as follows:

\begin{itemize}
  \item \textbf{Crash failure}: The interlinker crashes or halts.
  \item \textbf{Omission failure}: The interlinker fails to push a transaction upon seeing a new block.
  \item \textbf{Timing failure}: The interlinker pushes a transaction which fails to be included in the upcoming block.
  \item \textbf{Response failure}: The interlinker pushes a transaction with an invalid interlink.
  \item \textbf{Arbitrary failure}: The interlinker pushes a transaction before a new block is seen or pushes a duplicate for a specific upcoming block twice.
\end{itemize}

We will study how these failures can be mitigated in the next section.

\section{Viability}
Making the operation of the interlinker affordable is key in order to allow many parties to run it. We will estimate the cost of operation now.

Our transaction size ($\sf txBytes$) is constant at exactly 244 bytes. The median Bitcoin Cash fee per byte ($\sf feePerByte$) at the time of writing (November 2018) is 1 satoshi. Multiplied by our transaction size this gives us a transaction fee ($\sf txFee = txBytes * feePerByte$) of 244 satoshis.

\begin{table}
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    Cost per & Formula & Current estimation \\
    \hline
    Day & $\sf txFee * 10 * 24$ & 0.13€ \\
    Month & $\sf perDay * 30$ & 3.9€ \\
    Year & $\sf perMonth * 12$ & 46.8€ \\
    \hline
  \end{tabular}
\end{table}

We provide two implementations of an interlinker which both run in production. We'll now look at the pros and cons of each.

\section{Bitcoin-ABC}
Our first implementation is built on top of Bitcoin-ABC. Bitcoin-ABC is the reference implementation for Bitcoin Cash in C++. It is a fork of the original Bitcoin codebase (now Bitcoin Core), and it was the first ever implementation to support Bitcoin Cash. It has a very active community of developers and users. Due to its heritage from Bitcoin Core the code is very well written and tested, and any new feature for the Bitcoin Cash chain appears on Bitcoin-ABC first.

We run Bitcoin-ABC as a full node and interface with it using JSON-RPC. The interlinker is a Python module which knows (a) the location and credentials to connect with the full node and (b) the velvet fork genesis block id.

After the interlinker makes sure the full node is fully synced it starts waiting for new blocks. As described above we need our interlinker to get notified whenever there's a new block so that it can send a transaction with the new interlink for inclusion in the upcoming block. There's two options to get notified for new blocks from a full node.

The first option is to utilize the ZeroMQ~\cite{zmq} functionality of Bitcoin-ABC. If compiled with the appropriate flags, Bitcoin-ABC can create a ZeroMQ channel where it will send notifications for new blocks and transactions. While the method seems very modern, it has some pitfalls. The main pitfall is race conditions: it is possible that the node pushes out a ZeroMQ notification about a block, however that block has not finished saving in the node's database, causing an immediate \code{getblock} request on the block to fail. Also, the ZeroMQ functionality is not enabled by default: one needs to compile the node with specific flags. While both issues are not fatal, in order to keep the interlinker as compatible with existing nodes as possible and to avoid workarounds we decided against using this functionality.

What we ended up using is busy polling through JSON-RPC with the \code{getbestblockhash} method. Every 5 seconds the interlinker will check the best block hash and if it doesn't match the one previously given then this means that there's been a new block. The interval can be configured should one desire not to cause much strain to their system.

In case there's a new block, the interlinker will promptly compute the correct interlink for it, by updating the interlink with all the intermediate blocks from the velvet fork genesis up to and including the new block. It will then compute the Merkle Tree root and include it in an SPV tagged output. It will then wrap the output inside a change transaction and send it to the network.

It is important to note here that in order to send the transactions, the interlinker has to pay transaction fees as seen earlier. However, we haven't talked about the interlinker controlling a wallet or private keys which would make it seem like there is no way to fund the transactions. Because of how the JSON-RPC methods work we don't need to specify a private key or wallet external to the full node and we can let the full node create and pay for our transactions using its default wallet. Thus the way to fund the interlinker is to fund the default wallet of the full node.

code snippets TODO

\section{bcash}
The second implementation is build on top of the bcash JavaScript library. bcash implements a full node and wallet functionality exclusively in JavaScript without being based on the Bitcoin C++ codebase as did most previous solutions. A major advantage of bcash is that it implements an SPV node too, which is very useful since the interlinker only needs the block ids of the chain but doesn't care about the block contents, so requiring a full node to run it would be a waste of space and bandwidth.

\section{Deployment}
At the time of writing of this thesis, both interlinkers run in production on the Bitcoin Cash testnet chain and have been for over 2 months. We started with our first deployment late September 2018, with the first prototype of our Python interlinker. This gave us a chance to catch bugs that only appear on long running processes and make sure our software is resilient to network and other library failures. As new features and bug fixes kept rolling in our software we continuously updated the deployments.

docker images
docker-compose

\section{Experimental Data}
\begin{figure}
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{figures/testnet-deployment-reliability.pdf}
  \caption{Reliability of our testnet deployment.}
  \label{fig:testnet-deployment-reliability}
\end{figure}

We will now examine real-world data gathered from our Bitcoin Cash testnet deployment. On Figure~\ref{fig:testnet-deployment-reliability} we can look at the reliability of our interlinker deployment. We can see that about 60\% of the blocks have been correctly interlinked with our velvet transactions, and about 10\% of them only have 1 interlink pointer missing, which makes them potentially usable. With $\infty$ we denote the case where all pointers are missing due to a block only having incorrect interlinks or no interlinks at all.

\begin{figure}
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{figures/bitcoin-cash-testnet-levels.pdf}
  \caption{Level distribution on Bitcoin Cash testnet.}
  \label{fig:bitcoin-cash-testnet-levels}
\end{figure}

On Figure~\ref{fig:bitcoin-cash-testnet-levels} we see the level distribution on the Bitcoin Cash testnet. As expected, the level growth is logarithmic compared to the chain length.
