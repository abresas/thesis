\chapter{NIPoPoW Velvet Fork Prover}
Now that we've established a fork on the Bitcoin Cash chain, we show how our fork can be put to use by creating proofs. We introduce a kind of client called a \emph{prover} which can create all kinds of NIPoPoW proofs on demand.

Let's assume we have an SPV node. We set the bloom filter to our velvet fork tag in order to get all blocks containing only the transactions of the fork. It's possible to then extract from each transaction the payload, which should be the interlink commitment. Since anyone can post such transactions on the blockchain, we have to make sure that the commitment is actually true before we can use it. In order to do that we maintain our own version of the interlink for each block (similar to how the interlinker does) which we know is correct called $\sf realLink$. Then for every block, we compare its commitments (there may be many) with the Merkle Tree root of our $\sf realLink$. If there is a valid commitment we say that the block has a valid interlink. We store the full interlink as $\sf realLink[id(block)]$.

When we talked about NIPoPoWs we mentioned how it's essential that our proof forms a blockchain that can be traversed from start to end. In order to make our proof traversable, whenever we include a block we have to make sure it connects validly to the previous one either by (a) using the regular $\sf previd$ inside the block or (b) using a valid interlink. If we use the $\sf previd$ to link back to the previous block then all the information someone needs to verify the traversability is already there and we don't need to add anything extra. In the case we use the interlink however, we need to provide the Merkle Tree proofs for:

\begin{itemize}
  \item The transaction containing the valid interlink commitment.
  \item The interlink level we use for the connection.
\end{itemize}

If our chain is not traversable the proof is automatically invalid.

We'll now look at the concrete implementation of the prover.

\section{Invalid Interlink Handling}
The original NIPoPoWs paper~\cite{nipopows} gives us some insight into how to handle blocks with invalid interlinks. Let's look at where we need to make changes starting with suffix proofs.

For suffix proofs we need a way to obtain the upchain of a chain, denoted as $\chain\upchain^\mu$. When we first defined upchain we didn't explain how it should be implemented. Let's start with an implementation:

\subsection{followUp}
$\sf followUp$ takes a block $b$ and a level $\mu$ as parameters. It then tries to get back on a block of level $\mu$ by only using valid pointers. This means that in case a block doesn't have a valid interlink it will drop down to level 0 (via $\sf previd$) in order to keep going. It then returns 

\subsection{followDown}

\subsection{findVelvetUpchain}

\begin{lstlisting}[language=Python]
def upchain(chain, m):
  return [block for block in chain if level(block) >= m]
\end{lstlisting}

It's easy to see that blocks 

\section{bcash}
bcash, also used for the interlinker earlier, turns out the be the only option for an SPV node on Bitcoin Cash, making it the obvious choice for the prover.

\section{Testing}
Due to the real-time and asynchronous nature of the prover it's important that our implementation is resilient and bug-free. In order to assert that the code has been thoroughly unit tested, boasting a code coverage of >90\%. The tests are written and run with Jest. There are also integration tests using real-world data.
