\section{Primitives}
\subsection{Cryptographic Hash Functions}
A \textit{hash function} is a function used to map data of arbitrary size to data of a fixed size. Formally, a hash function $H$ is of the form $H: D \rightarrow [0, 2^\kappa)$, where $\kappa$ is a characteristic of $H$, specifically the number of bits of its output.

For a hash function to be a cryptographic hash function it has to satisfy the following properties:
\begin{itemize}
  \item \textbf{Pre-image resistance}: Given a hash of $h$ it should be difficult to compute an input $m$ such that $H(m) = h$.
  \item \textbf{Second pre-image resistance}: Given an input $m_1$ it should be difficult to compute an input $m_2$ such that $H(m_1) = H(m_2)$.
  \item \textbf{Collision resistance}: It should be difficult to compute two inputs $m_1$ and $m_2$ such that $H(m_1) = H(m_2)$.
\end{itemize}

Bitcoin utilizes two hash functions, SHA256 ($\kappa=256$) and RIPEMD160 ($\kappa=160$).

This work and the works it is based on \cite{nipopows} operate under the Random Oracle model where hash functions are assumed to have uniformly distributed outputs in their output domain, meaning that $\forall x, y: Pr[H(x) = y] = \frac{1}{2^\kappa}$.

\subsection{Public-key Cryptography}
Each user is assumed to have a \textit{key pair} composed of a \textit{public key} which can be shared freely and a \textit{private key} which should be kept secret. A public-key cryptographic system should implement the following operations:

\begin{itemize}
  \item $Encrypt_{public}(m)$
  \item $Decrypt_{private}(m)$ where $\forall m: \exists! enc: Decrypt_{private}(enc) = m \land enc = Encrypt_{public}(m)$
  \item $Sign_{private}(m) = Encrypt_{private}(m)$
  \item $Verify_{public}(m) = Decrypt_{public}(m)$ where $\forall m: \exists! sig: Verify_{public}(sig) = True \land sig = Sign_{private}(m)$
\end{itemize}

\subsection{Merkle Trees}
\subsection{Bloom Filters}
