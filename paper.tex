\documentclass[11pt]{llncs}
\usepackage{preamble}

\begin{document}
\title{Constructing interoperable blockchains using NIPoPoWs}
\date{\today}
\author{Kostis Karantias\\
    \email{cse32454@cse.uoi.gr}}
\institute{University of Ioannina}
\maketitle
\noindent
\makebox[\linewidth]{\small \today}

\newpage

\begin{abstract}
  In this paper we examine the real-world applications of the recent blockchain
  primitive called Non Interactive Proofs of Proof of Work (NIPoPoWs). We
  enable the use of the primitive on Bitcoin Cash by implementing the first
  known velvet fork on a blockchain. We provide concrete implementations for
  creating a velvet fork, and generating proofs on a blockchain that has been
  forked in this way.
\end{abstract}

\newpage

\tableofcontents

\newpage

\thispagestyle{plain}

\section{Introduction}

\subsection{Related Work}
\subsection{Objectives}
\subsection{Structure}

\section{Background}

\subsection{Bitcoin}
Bitcoin was introduced in 2008 by Satoshi Nakamoto~\cite{bitcoin} as a
peer-to-peer version of electronic cash, allowing online payments to be sent
directly between parties without the need of a intermediary.

Transfer of value in Bitcoin happens with transactions. A transaction has
inputs and outputs. An output is where the value creation happens for the
receiver. An output can be later redeemed by using its designated receiver's
private key and turned into an input to be used for another transaction.

TODO

\subsubsection{Block Structure}
A block header contains mainly the hash of the previous block, a Merkle root
hash to commit to a set of transactions, and a nonce.

After the block header comes the series of transactions included in the block.

TODO

\subsubsection{Proof of Work}
\subsubsection{Merkle Trees}
A Merkle tree~\cite{merkle} is a data structure which allows a party to
commit to a set of items using only a single hash, and prove the inclusion of
any item in the committed set by providing a logarithmic proof in terms of the
cardinality of the set.

More specifically, the hashes of the items consist the leafs of the tree, and
the last level. The internal levels are defined recursively as follows: To
create level $k-1$ each pair of level $k$ $(A, B)$ is transformed as a node
of value $H(A || B)$ which points to both $A$ and $B$. If the number of nodes
at level $k$ is odd, the last node at that level is paired with itself.
\footnote{This specific construction is the one Bitcoin implements. There are
various other constructions which are not inside the scope of this paper.}

Merkle trees are useful in Bitcoin in order to commit to a set of
transactions to be included in a block while keeping the block header of a
constant size.

\subsubsection{Simplified Payment Verification}
The size of the blockchain has reached 185GB by September 2018, which makes
it a very time consuming or even infeasible process to synchronise a full
node. Fortunately, a solution was proposed in the original whitepaper
~\cite{bitcoin}, which allows the creation of so-called \textit{lite nodes}.
Lite nodes only know the headers of the entire blockchain, which are
constant-size for each block (80 bytes). At the time of writing of this
paper, the size of all block headers was \~{}42MB\@. The lite node then asks the
network for transactions concerning it (e.g.\ transactions concerning a
specific public key). Full nodes of the network find such transactions and
return them to the requester. For each transaction, the block header of the
block it's included in is returned, along with a Merkle tree proof of
inclusion which the lite node can then verify. This protocol is reliable as
long as an adversary does not control the network of a lite node.

\subsubsection{Bitcoin Cash}
In 2017 Bitcoin faced severe scalability issues~\cite{onscaling}. Its limited
1MB block size meant that it could only support a maximum of 7 transactions per
second. As Bitcoin's popularity had exploded at the time, the problem was
hugely exacerbated. The most prominently proposed solution for this was a block
size increase, however no consensus was reached. The discussions ended with a
fork of the main Bitcoin chain which allowed for 8MB blocks, called Bitcoin
Cash.

\subsection{Non-Interactive Proofs of Proofs of Work}

\subsubsection{Sublinear SPV}
We would like to be able to prove statements like:

\begin{itemize}
  \item We have a valid chain where the last $k$ blocks are the ones we're
    claiming. This is called a \textbf{suffix proof}.
  \item We have a valid chain where a specific given block is included. This is
    called an \textbf{infix proof}.
\end{itemize}

Our current best solution, SPV, requires providing the whole chain's block
headers as proof. This is obviously linear in the size of the chain.

There have been previous attempts to create proofs smaller in size than SPV
proofs~\cite{KLS}, where a scheme for logarithmic proofs was proposed.
This scheme was later proven insecure~\cite{nipopows}.

NIPoPoWs is the first secure construction~\cite{nipopows} for logarithmic
proofs.

\subsubsection{Assumptions}
An assumption NIPoPoWs make is that the difficulty is constant. This is not
true for Bitcoin or Bitcoin Cash.

NIPoPoWs also assume each block contains an interlink data structure, which
we'll study shortly. Interlinks too don't exist in Bitcoin or Bitcoin Cash.

In the next section we'll look at how we sidestep all those issues.

\subsubsection{Levels}
At the heart of the primitive lies the separation of blocks into levels. The
level of a block is defined as $\textit{level}(B) = \left \lfloor \log(T) -
\log(\sf{id}(B)) \right \rfloor$, where $T$ is the constant difficulty of the
blockchain. The genesis block is an exception to this rule as
$\textit{level}(Gen) = \infty$. We call a block of level $\mu$ a $\mu$-superblock.

Intuitively, the level of a block is the number of leading zeros of the binary
representation of the block id when left padded to the length of $T$. An
example of this can be seen on Table~\ref{table:level-counting}.

\begin{table}
  \centering
  \begin{tabular}{|c|c|}
    \hline
    $T$ & 1110000 \\
    \hline
    $\sf{id}(B)$ & \underline{000}1000 \\
    \hline
  \end{tabular}
  \caption{Calculating the level of a block by counting the leading zeros (3 in this case).}
  \label{table:level-counting}
\end{table}

Figure~\ref{fig:hierarchy} shows an example the implied blockchain created from the superblocks.

\begin{figure}
  \centering
  \includegraphics[width=0.9\columnwidth,keepaspectratio]{figures/hierarchical-ledger.png}
  \caption{The hierarchical blockchain.
  Higher levels have achieved a lower target (higher difficulty) during
  mining. All blocks are connected to the genesis block $G$. Source:~\cite{nipopows}}
  \label{fig:hierarchy}
\end{figure}

\subsubsection{Interlink}
Instead of keeping only the hash of the previous block inside the block header,
we could keep pointers to the previous superblock of every level. The structure
containing these pointers is called the interlink. Bitcoin does not support
such a structure in the block header but we will study how to sidestep this
issue by velvet forking in a few sections.

\subsubsection{Suffix Proofs}
\subsubsection{Infix Proofs}
\subsubsection{Proof Verification}
\subsubsection{Velvet Forks}
Velvet forks~\cite{nipopows,velvet} describe a formalization of adding
arbitrary data inside blocks in order to allow potential applications without
sacrificing the backwards compatibility of the blockchain. TODO

\subsubsection{User-Activated Velvet Forks}

\section{Bitcoin Cash Velvet Fork Implementation}

\subsection{Bitcoin-ABC}
\subsection{Interlinker}

\section{NIPoPoW Velvet Fork Prover Implementation}

\subsection{bcash}
\subsection{Testing}

\section{Results \& Future Work}

\bibliography{bibliography}

\end{document}
