\documentclass[11pt]{llncs}
\usepackage{preamble}

\begin{document}
\title{Constructing interoperable blockchains using NIPoPoWs}
\date{\today}
\author{Kostis Karantias\\
    \email{cse32454@cse.uoi.gr}}
\institute{University of Ioannina}
\maketitle
\noindent
\makebox[\linewidth]{\small \today}

\newpage

\begin{abstract}
  In this paper we examine the real-world applications of the recent blockchain
  primitive called Non Interactive Proofs of Proof of Work (NIPoPoWs). We
  enable the use of the primitive on Bitcoin Cash by implementing the first
  known velvet fork on a blockchain. We provide concrete implementations for
  creating a velvet fork, and generating proofs on a blockchain that has been
  forked in this way.
\end{abstract}

\newpage

\tableofcontents

\newpage

\thispagestyle{plain}

\section{Introduction}

\subsection{Related Work}
\subsection{Objectives}
\subsection{Structure}

\section{Background}

\subsection{Bitcoin}

Bitcoin was introduced in 2008 by Satoshi Nakamoto~\cite{bitcoin} as a
peer-to-peer version of electronic cash, allowing online payments to be sent
directly between parties without the need of a intermediary.

Transfer of value in Bitcoin happens with transactions. A transaction has
inputs and outputs. An output is where the value creation happens for the
receiver. An output can be later redeemed by using its designated receiver's
private key and turned into an input to be used for another transaction.

\subsubsection{Block Structure}
\subsubsection{Proof of Work}
\subsubsection{Merkle Trees}
A Merkle tree~\cite{merkle} is a data structure which allows a party to
commit to a set of items using only a single hash, and prove the inclusion of
any item in the commited set by providing a logarithmic proof in terms of the
cardinality of the set.

More specifically, the hashes of the items consist the leafs of the tree, and
the last level. The internal levels are defined recursively as follows: To
create level $k-1$ each pair of level $k$ $(A, B)$ is transformed as a node
of value $H(A || B)$ which points to both $A$ and $B$. If the number of nodes
at level $k$ is odd, the last node at that level is paired with itself.
\footnote{This specific construction is the one Bitcoin implements. There are
various other constructions which are not inside the scope of this paper.}

Merkle trees are useful in Bitcoin in order to commit to a set of
transactions to be included in a block while keeping the block header of a
constant size.

\subsubsection{Simplified Payment Verification}
The size of the blockchain has reached 185GB by September 2018, which makes
it a very time consuming or even infeasible process to synchronise a full
node. Fortunately, a solution was proposed in the original whitepaper
\cite{bitcoin}, which allows the creation of so-called \textit{lite nodes}.
Lite nodes only know the headers of the entire blockchain, which are
constant-size for each block (80 bytes). At the time of writing of this
paper, the size of all block headers was \~{}42MB. The lite node then asks the
network for transactions concerning it (e.g. transactions concerning a
specific public key). Full nodes of the network find such transactions and
return them to the requestor. For each transaction, the block header of the
block it's included in is returned, along with a Merkle tree proof of
inclusion which the lite node can then verify. This protocol is reliable as
long as an adversary does not control the network of a lite node.

\subsubsection{Bitcoin Cash}
In 2017 Bitcoin faced severe scalability issues~\cite{onscaling}. Its limited
1MB block size meant that it could only support a maximum of 7 transactions per
second. As Bitcoin's popularity had exploded at the time, the problem was
hugely exacerbated. The most prominently proposed solution for this was a block
size increase, however no consensus was reached. The discussions ended with a
fork of the main Bitcoin chain which allowed for 8MB blocks, called Bitcoin
Cash.

\subsection{Non-Interactive Proofs of Proofs of Work}

\subsubsection{Sublinear SPV}
There have been previous attempts to create proofs smaller in size than SPV
proofs~\cite{KLS}. NIPoPoWs is the first secure construction~\cite{nipopows}.
TODO

\subsubsection{Interlink}
The idea behind interlinks comes in 2012~\cite{highway}. TODO

\subsubsection{Proof Verification}
\subsubsection{Suffix Proofs}
\subsubsection{Infix Proofs}
\subsubsection{Velvet Forks}
Velvet forks~\cite{nipopows,velvet} describe a formalization of adding
arbitrary data inside blocks in order to allow potential applications without
sacrificing the backwards compatibility of the blockchain. TODO

\subsubsection{User-Activated Velvet Forks}

\section{Bitcoin Cash Velvet Fork Implementation}

\subsection{Bitcoin-ABC}
\subsection{Interlinker}

\section{NIPoPoW Velvet Fork Prover Implementation}

\subsection{bcash}
\subsection{Testing}

\section{Results \& Future Work}

\bibliography{bibliography}

\end{document}
